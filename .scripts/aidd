#!/bin/bash

[[ "$#" -lt 1 ]] && echo "Usage: aidd [code|test]" && exit 0

case "$1" in
    "code")
echo "Given the below code, file structure, requirement and general rule:

<file_structure>
$(tree --gitfile .gitignore)
</file_structure>

<code>
$(catai m -)
</code>

<requirement>
Help me <do stuff, add more explanation and constraint>.
</requirement>

<general_rule>
As a lead developer of the project, you will start with high level ideas on how you would implement this, considering all security and performance issues with it.
Think for as much as you want. Then, for now and the rest of this session:

- Only output code AFTER I have reviewed the strategy. You may realize that you need some file to know more about the system implementation, so feel free to ask me for it.
- Make sure you output professional-grade, production-ready code that is clean, optimized, maintainable and follow best practices.
- Print the code addition or change in 'git diff' format (meaning they have the filename, the lines that got changed, and ignore the parts that is unchanged).
- The change must be compatible to be used in the 'patch' program to apply the changes. Follow the line numbers correctly, especially the starting line of the change.
- If printing out 'diff' file, then do not print out any other code block.
</general_rule>
"
        ;;

    "test")
echo "Help me add test coverage to the <class, component or feature> below.

- Start with outlining the scenarios, make sure to cover different paths that the code handles, together with edge cases.
- Do not provide test code right away, only after I have confirmed that the scenarios look good.
- Follow the existing testing styles and conventions where applicable.

<optionally provide feature descriptions and acceptance criteria>

<code>
$(catai m -)
</code>
"
        ;;

    *)
        echo "Usage: aidd [code|test]" && exit 1
        ;;
esac

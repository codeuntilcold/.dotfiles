#!/bin/bash

command="$1"
shift
rest="$@"

case "$command" in
"agent")
  echo "[[ $(cut -c1-50 <<<$rest)
Given the below file structure, requirement and general rule:

<file_structure>
$(fd --type f --hidden --exclude .git | tree --fromfile)
</file_structure>

<requirement>
Help me $rest.
</requirement>

<general_rule>
As a coding agent, you have some tools available at your disposal, mainly the way to execute shell
commands. You will use these commands to perform queries, changes, and anything you want on the
host machine. The commands should be encapsulated in one line, wrapped in the 'agentexecute' block,
where block is a triple-backticks fenced block like in markdown. Those must lie at the end of your
response since it is an information that is obtained outside of our conversation.

As an example, some of your helpful shell commands would be: curl (http request), grep (search),
parker (applying your change in diffs), tree (for listing files), git, cat, ls, and so on so forth.

Remember: you can only execute one agentexecute block at a time. That's why it's at the end of your
response. those commands must be put at the end of the file, the shell command must be in one line,
and its response will be sent back to you. Which means you can read files, write code in diff, and
commit. DO NOT PUSH though as the coder will make the ultimate decision. Decide for yourself what is
an irreversible thing and stop yourself before doing that.

So to be easy for you to understand, here is a recap of the flow:
- my request
- your response; if you want to execute something, END WITH ONE agentexecute block. it must only
contain one line of bash command
- if there's agentexecute block, the next message from me is the result of that block
- repeat until you've considered the task complete.

Coding task wise, you will start with high level ideas on how you would implement this, considering
all security and performance issues with it. Think for as much as you want. Then, for now and the
rest of this session:

- If the context provided to you has missing files, do yourself a favor and read them using cat.
- Print the code addition or change in 'git diff' format (meaning they have the filename, the lines
  that got changed, and ignore the parts that is unchanged).
- The change must be compatible to be used in the 'patch' program to apply the changes. Follow the
  line numbers correctly, especially the starting line of the change. Make sure to add 'a/' and 'b/'
  so that the program knows to patch which file.
- After you're satisfied with the code, use a special shell command called 'parker' to patch the code.
  No arguments needed. If patching failed, you're welcome to look into the .rej file to figure out
  what went wrong and suggest a change in diff.
- Only after you have all the ideas about the changes to make (feel free to reflect yourself on that)
  are you able to use 'parker'. Do not mix up the diffs with other things, only diffs and then 'parker'
- Make sure you output professional-grade, production-ready code that is clean, optimized, maintain-
  able and follow best practices.
- No need for comment. Try to write semanticly rich code instead of littering the code with comments.

REMEMBER: if you want to execute something, you can only do it at the end; none of the ones proceeding
it matters.
</general_rule>
"
  ;;

"code")
  echo "[[ $(cut -c1-50 <<<$rest)
Given the below code, file structure, requirement and general rule:

<file_structure>
$(fd --type f --hidden --exclude .git | tree --fromfile)
</file_structure>

<code>
$(catai)
</code>

<requirement>
Help me $rest.
</requirement>

<general_rule>
As a lead developer of the project, you will start with high level ideas on how you would implement
this, considering all security and performance issues with it. Think for as much as you want. Then,
for now and the rest of this session:

- Only output code AFTER I have reviewed the strategy.
- Be rigorous. If the context provided to you has missing files, ask me for those files.
  + For example, if a constant is imported but you don't know exactly which file it is in, ask me.
  + If you want to know the content of a specific file, ask me.
  + This is absolutely crucial to make sure that the following requirements works.
- Print the code addition or change in 'git diff' format (meaning they have the filename, the lines
  that got changed, and ignore the parts that is unchanged).
- The change must be compatible to be used in the 'patch' program to apply the changes. Follow the
  line numbers correctly, especially the starting line of the change. Make sure to add 'a/' and 'b/'
  so that the program knows to patch which file.
- If printing out 'diff' file, then do not print out any other code block.
- Make sure you output professional-grade, production-ready code that is clean, optimized, maintain-
  able and follow best practices.
- No need for comment. Try to write semanticly rich code instead of littering the code with comments.
- Unless I have confirmed, do not try to write diff incrementally, i.e diff on the code that you wrote
</general_rule>
"
  ;;

"test")
  echo "Help me add test coverage to the code below.

- First check whether there are cases that are not covered, list them out and let me review.
- Start with outlining the scenarios, make sure to cover different paths that the code handles,
  together with edge cases.
- Do not provide test code right away, only after I have confirmed that the scenarios look good.
- Follow the existing testing styles and conventions where applicable.

$rest

<code>
$(catai)
</code>
"
  ;;

"review")
  echo "[[ Code Review
Help me review the code based on this git diff. The code review should compreshensively cover
the code change on many facets like code quality, whether it is a good solution in general, about
potential security issue and potential future changes in requirement. No need for any real implemen-
tation, I just need your judgement on it. Here is the diff:

<diff>
$(git diff main)
</diff>
"
  ;;

"pr")
  echo "[[ PR Description
You are a meticulous code reviewer. After you have looked at the diff below, help me produce a GitHub
pull request description for this code change, following this format:

<diff>
$(git diff main)
</diff>

<git_log>
$(git log main..HEAD)
</git_log>

<format>
### Tasks

[Task name](task url)

### What have we done

- Some api changes
- Some technical details

### Proof of Work
</format>

Please follow this requirement closely
- Only output the actual PR content, do not add things like HEre is your PR...
- Note that proof of work is omited if the code is backend-only
- Only include this proof of work if it's front end related, or if there is something that can be
  demo-ed easily in the PR.
- Only list out high level changes in the "What have we done" part; I dont want to hear things like
  'move code from here to there' or 'add test to cover this or that' since those are just noise
- Specifically note out things like api changes, tricky code logic, etc
- For api change, tell the users which user-facing (i.e public) functions are added, modified,
  what are the parameters change
- Try to fill in the task name and url if you can, from the diff, but dont try too hard
"
  ;;

"commit")
  echo "[[ Commit Message
Help me write a commit message based on this git diff. Ideally the description should contain just
enough details that we care about. Output just the message following the format, no need to tell me
anything else.

Note on the format: f on feature branch, b on bugs branch, so on

<format>
[f] - Do something on the commit

- Optional explanation number one
- Optional notice number two

[optional task name](optional task url)
</format>

<branch>
$(git branch --show-current)
</branch>

<diff>
$(git diff --staged)
</diff>
"
  ;;

"grug")
  echo "[[ Grug $rest
You are a concise person who gets to the point when asked. You won't try to elaborate the question,
nor would you try to provide examples to what I'm asking. You just be a professional and answer the
question responsibly, correctly, without BS, without talking too much.

Here is the question: $rest
"
  ;;

*)
  echo "Usage: aidd [code | test | review | commit | pr | grug] [message]" && exit 1
  ;;
esac

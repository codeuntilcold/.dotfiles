#!/usr/bin/env bash

set -o vi

BASE_URL="https://admin.skydeck.ai/api/v1"
CURRENT_RESPONSE_FILE="/tmp/sdai-conv-000000.md"
CACHE_FILE="/tmp/sdai-cache.txt"
CACHE_TIMEOUT=300 # 5 minutes

COOKIE_FILE="$HOME/.sdai/cookies"
COUNT_FILE="$HOME/.sdai/count.txt"
HEADER_REFERER="Referer: https://eastagile.skydeck.ai/"

BG='\e[1;32m'
CLR='\e[0m'

declare -A MODELS
MODELS["cl-sonnet"]=5101
MODELS["cl-haiku"]=5171
MODELS["gpt4o"]=4094
MODELS["gpt4o-mini"]=4430
MODELS["gem-flash"]=5270
MODELS["gem-pro"]=5269
MODELS["gem-exp"]=5271

STREAMING="false"
CONVERSATION_ID=""
ASSI_MESSAGE_ID=""
MODEL_NAME=$1
MODEL_ID=${MODELS[$1]}

set_model() {
  MODEL_NAME=$1
  MODEL_ID=${MODELS[$1]}
}

spinner() {
  local rest=""
  local spinstr='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'

  while true; do
    printf " %s " "${spinstr:0:1}"
    rest=${spinstr#?}
    spinstr=$rest${spinstr:0:1}
    sleep 0.1
    printf "\r"
  done
}

pick_model() {
  local selected=$(
    [[ -z $1 ]] &&
      (for key in ${!MODELS[@]}; do echo $key; done | fzf --prompt="Select a model: ") ||
      (for key in ${!MODELS[@]}; do echo $key; done | fzf --filter $1 | head -n 1)
  )

  [[ -z "$selected" ]] && echo "Model selection cancelled" && return

  set_model $selected
  echo "Model changed to $MODEL_NAME (ID: $MODEL_ID)"
}

invalidate_cache() {
  [[ -f "$CACHE_FILE" ]] && rm $CACHE_FILE
}

refresh() {
  local exp=$(grep "_access" $COOKIE_FILE | cut -f7 | jwt | jq '.exp')

  [ "$(date +%s)" -gt "$exp" ] &&
    curl -s -X POST -o /dev/null "$BASE_URL/authentication/token/refresh/" \
      -H "$HEADER_REFERER" --cookie "$COOKIE_FILE" --cookie-jar "$COOKIE_FILE"
}

call() {
  refresh
  curl -s --cookie "$COOKIE_FILE" -H "Content-Type: application/json" -H "$HEADER_REFERER" "$@"
}

call_form() {
  refresh
  curl -s --cookie "$COOKIE_FILE" -H "Content-Type: multipart/form-data" -H "$HEADER_REFERER" "$@"
}

get_conversations() {
  [ ! -f $CACHE_FILE ] && call "$BASE_URL/conversations/?sort_by=created" | tee "$CACHE_FILE"

  local cur=$(date +%s)
  local mod=$([ $(uname) = 'Linux' ] && stat --format=%Y $CACHE_FILE || stat -f %m $CACHE_FILE)
  if [ $((cur - mod)) -lt $CACHE_TIMEOUT ]; then
    cat "$CACHE_FILE"
  else
    call "$BASE_URL/conversations/?sort_by=created" | tee "$CACHE_FILE"
  fi
}

pick_conversation_id() {
  get_conversations | jq -c '.results[] | { id, name, size }' | fzf | jq '.id'
}

delete_conversation() {
  call "$BASE_URL/conversations/$CONVERSATION_ID" -o /dev/null -X DELETE &
}

patch_conversation() {
  call "$BASE_URL/conversations/$CONVERSATION_ID" -o /dev/null -X PATCH -d '{ "name": "'"$1"'" }' &
}

post_user_message() {
  call_form "$BASE_URL/conversations/chat_v2/" --form-string "message=$1" -F "model_id=$MODEL_ID" \
    -F "regenerate_message_id=-1" -F "conversation_id=$CONVERSATION_ID"
}

get_response_stream() {
  increment_message_count

  STREAMING="true"
  call "$BASE_URL/conversations/streaming/" --data '{"message_id": '"$ASSI_MESSAGE_ID"' }' --no-buffer |
    tee $CURRENT_RESPONSE_FILE |
    bat --paging=never --style=rule --language=markdown

  STREAMING="false"
}

stop_response_stream() {
  [ "$STREAMING" == "false" ] && exit

  call "$BASE_URL/conversations/messages/$ASSI_MESSAGE_ID/stop-streaming/" -o /dev/null -d "{}"
  printf "\n$BG[Interrupted]$CLR"
}

increment_message_count() {
  local current=$(cat $COUNT_FILE)
  echo $((current + 1)) >$COUNT_FILE
}

count_messages() {
  cat $COUNT_FILE
}

count_messages_old() {
  local last_monday=$([ $(uname) = 'Linux' ] && date -dlast-mon +%s || date -v-sun -u +%s)
  (
    call "$BASE_URL/conversations/?sort_by=created" | jq -c '.results[] | { num_of_unread_messages, created }' &
    call "$BASE_URL/conversations/?sort_by=created&page=2" | jq -c '.results[] | { num_of_unread_messages, created }' &
    wait
  ) | while IFS= read -r conv; do
    local created=$(echo "$conv" | jq -r '.created' | sed 's/\.[0-9]*Z$//') # trim off milliseconds
    local unread=$(echo "$conv" | jq -r '.num_of_unread_messages')

    local created=$(
      [ $(uname) = 'Linux' ] &&
        date --date="$created" +%s || date -u -j -f %Y-%m-%dT%H:%M:%S +%s "$created"
    )
    [ $created -gt "$last_monday" ] && echo $unread
  done | awk '{sum += $1} END {print sum / 2}'
}

dash() {
  printf "$BG%$(tput cols)s$CLR" | tr " " "—"
  echo
}

clean_message() {
  # jq -Rrs '.' <<<"$1"
  printf "$1"
}

start_chat_session() {
  echo "SkyDeck.ai with $MODEL_NAME"
  dash

  while true; do
    local queryfile="/tmp/sdai-query-$CONVERSATION_ID.md"

    # use a local version of `gum` to map enter to new line, ctrl+d to submit
    message=$(
      ~/.local/bin/gum write --char-limit=0 --width=0 --height=0 --no-show-help
    ) || exit 0

    if [[ "$message" = "" ]]; then
      nvim "$queryfile"
      message=$(cat "$queryfile")
    else
      echo "$message"
    fi

    # setting conversation title using prefix [[ on first line
    local first_line=$(echo "$message" | head -n 1)
    if [[ "$first_line" =~ ^\[\[ ]]; then
      conversation_title=$(echo "$first_line" | sed -n 's/^\[\[ \(.*\)/\1/p')
      message=$(echo "$message" | tail -n +2)
    fi

    # use aidd prompt
    if [[ "$message" =~ ^/u ]]; then
      aidd $(echo $message | cut -f2- -d' ') >"$queryfile"
      nvim "$queryfile"
      message=$(cat "$queryfile")
    fi

    # parker
    if [[ "$message" =~ ^/p ]]; then
      parker
      dash
      continue
    fi

    # model
    if [[ "$message" =~ ^/m ]]; then
      read -r _ model <<<"$message"
      pick_model "$model"
      dash
      continue
    fi

    # yank
    if [[ "$message" =~ ^/y ]]; then
      read -r _ block <<<"$message"
      if [[ -z "$block" ]]; then
        pbcopy <$CURRENT_RESPONSE_FILE
        echo "Yanked content to clipboard"
      else
        cat $CURRENT_RESPONSE_FILE | sed -n '/^```'"$block"'.*$/,/^```$/p' | sed '/^```/d' | pbcopy
        echo "Yanked $block to clipboard"
      fi
      dash
      continue
    fi

    if [[ "$message" = "/share" ]]; then
      echo https://eastagile.skydeck.ai/conversation/$(
        call "$BASE_URL/conversations/collaboration/start" --data '{"conversation_id":'"$CONVERSATION_ID"'}' |
          jq -R '.data.collaboration_slug'
      )
      dash
      continue
    fi

    if [[ "$message" = "/view" ]]; then
      nvim -R $CURRENT_RESPONSE_FILE
      dash
      continue
    fi

    if [[ "$message" = "/viewdiff" ]]; then
      cat $CURRENT_RESPONSE_FILE | sed -n '/^```diff$/,/^```$/p' | sed '/^```/d' | nvim -R -
      dash
      continue
    fi

    if [[ "$message" = "/clear" ]]; then
      clear
      continue
    fi

    message=$(clean_message "$message")

    dash

    spinner &
    spinner_id=$!

    response=$(post_user_message "$message")
    CONVERSATION_ID=$(jq -r '.data.conversation_id' <<<"$response")
    ASSI_MESSAGE_ID=$(jq -r '.data.assistant_message_id' <<<"$response")

    kill $spinner_id
    wait $! 2>/dev/null
    echo -ne '\r   \r'

    trap stop_response_stream SIGINT

    printf "$BG($MODEL_NAME)$CLR\n"
    time get_response_stream
    echo

    trap - SIGINT
    dash

    [[ ! -z "$conversation_title" ]] && patch_conversation "$conversation_title"
  done
}

one_time_prompt() {
  message=$(aidd "$@") || echo "No such aidd template: $1" && exit 1

  # setting conversation title using prefix [[ on first line
  local first_line=$(echo "$message" | head -n 1)
  if [[ "$first_line" =~ ^\[\[ ]]; then
    conversation_title=$(echo "$first_line" | sed -n 's/^\[\[ \(.*\)/\1/p')
    message=$(echo "$message" | tail -n +2)
  fi

  message=$(clean_message "$message")

  response=$(post_user_message "$message")
  CONVERSATION_ID=$(jq -r '.data.conversation_id' <<<"$response")
  ASSI_MESSAGE_ID=$(jq -r '.data.assistant_message_id' <<<"$response")

  get_response_stream

  [[ ! -z "$conversation_title" ]] && patch_conversation "$conversation_title"
}

get_conversation_history() {
  wscat -c "wss://admin.skydeck.ai/ws/connect/" \
    -H "Origin: https://eastagile.skydeck.ai" \
    -H "Cookie: eastagile_access=$(grep "_access" $COOKIE_FILE | cut -f7)" \
    -x '{"type":"user_opened_conversation","data":{"conversation_id":'"$CONVERSATION_ID"'}}' |
    jq -r '.data.messages.[].content' |
    bat --paging=never --style=rule --language=markdown
}

usage() {
  echo "Usage: $(basename $0) [chat | continue | delete | patch | query-models | count-conv | read-cont]"
  exit 1
}

main() {
  [[ "$#" -lt 1 ]] && usage

  case "$1" in
  c | chat)
    refresh &
    start_chat_session
    ;;
  cont | continue)
    refresh
    CONVERSATION_ID=$(pick_conversation_id)
    start_chat_session
    ;;
  d | delete)
    refresh
    CONVERSATION_ID=$(pick_conversation_id) || echo "No conversation selected" && exit 1

    delete_conversation
    invalidate_cache
    ;;
  p | patch)
    refresh
    CONVERSATION_ID=$(pick_conversation_id) || echo "No conversation selected" && exit 1

    read -p "Enter new name: " name
    patch_conversation $name
    ;;
  pc | pick-chat)
    pick_model
    refresh &
    start_chat_session
    ;;
  query-models)
    refresh
    call "$BASE_URL/models/" | jq -r '.[] | [ .id, .name, .context_window ] | @tsv' | column -t -s $'\t' | sort -k2
    ;;
  count-conv)
    count_messages
    ;;
  read-cont)
    CONVERSATION_ID=$(pick_conversation_id) || echo "No conversation selected" && exit 1
    get_conversation_history
    start_chat_session
    ;;
  *)
    refresh
    one_time_prompt "$@"
    ;;
  esac
}

set_model $([ -t 0 ] && echo "cl-sonnet" || echo "cl-haiku")

main "$@"
